‘\’，转义字符
为了逐字表达，你必须在"^.$()¦*+?{\"这些字符前加上转移字符'\'。
请注意在方括号中，不需要转义字符。

‘^’和’$’
'^'：指出一个字符串的开始
"$"：指出一个字符串的结尾
"^The"：表示所有以"The"开始的字符串（"There"，"The cat"等）；
"of despair$"：表示所以以"of despair"结尾的字符串；
"^abc$"：表示开始和结尾都是"abc"的字符串——呵呵，只有"abc"自己了；
"notice"：表示任何包含"notice"的字符串（如果不适用特殊字符，表示notice在被查找的字符串的任意部分）。
方括号中用'^'表示不希望出现的字符，'^'应在方括号里的第一位。（如："%[^a-zA-Z]%"表
示两个百分号中不应该出现字母）。

‘*’，’+’和’?’，表示一个或一序列字符重复出现的次数
'*'：“没有或更多”
'+'：“一次或更多”
'?'：“没有或一次”
"ab*"：表示一个字符串有一个a后面跟着零个或若干个b。（"a", "ab", "abbb",……）；
"ab+"：表示一个字符串有一个a后面跟着至少一个b或者更多；
"ab?"：表示一个字符串有一个a后面跟着零个或者一个b；
"a?b+$"：表示在字符串的末尾有零个或一个a跟着一个或几个b。

‘{}’，用以表示重复次数的范围
"ab{2}"：表示一个字符串有一个a跟着2个b（"abb"）；
"ab{2,}"：表示一个字符串有一个a跟着至少2个b；
"ab{3,5}"：表示一个字符串有一个a跟着3到5个b。
请注意，你必须指定范围的下限（如："{0,2}"而不是"{,2}"）。还有，你可能注意到了，'*'，'+'和'?'相当于"{0,}"，"{1,}"和"{0,1}"。

‘¦’，表示“或”操作
"hi¦hello"：表示一个字符串里有"hi"或者"hello"；
"(b¦cd)ef"：表示"bef"或"cdef"；
"(a¦b)*c"：表示一串"a""b"混合的字符串后面跟一个"c"；

‘[]’，表示某些字符允许在一个字符串中的某一特定位置出现
"[ab]"：表示一个字符串有一个"a"或"b"（相当于"a¦b"）；
"[a-d]"：表示一个字符串包含小写的'a'到'd'中的一个（相当于"a¦b¦c¦d"或者"[abcd]"）；
"^[a-zA-Z]"：表示一个以字母开头的字符串；
"[0-9]%"：表示一个百分号前有一位的数字；
",[a-zA-Z0-9]$"：表示一个字符串以一个逗号后面跟着一个字母或数字结束。

‘.’，可以替代任何字符
"a.[0-9]"：表示一个字符串有一个"a"后面跟着一个任意字符和一个数字；
"^.{3}$"：表示有任意三个字符的字符串（长度为3个字符）；

预定义字符集d,D,s,S,w,W,A,Z,b,B
'\d':数字[0-9]
'\D':非数字:
'\s':匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
'\S':匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
'\w':匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。
'\W':匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。
'\A':仅匹配字符串开头，同^
'\Z':仅匹配字符串结尾，同$
'\b':匹配单词边界，例如’er\b’可以匹配’never’中的’er’,但不能匹配’very’中的’er’，因为never中的er单词的右边界。

针对\b，我们来举几个列子：
import re
W = re.findall(‘\btina’, ‘tina tinaaaa’)
Print(w)
结果：
[‘tina’, ‘tina’]。原因是因为上述字符串可以拆分成两个单词，tina都是上述两个单词的左边界。
常用函数
import re
匹配所有，直接返回匹配结果
re.findall
re.sub 替换，返回替换后结果

re.match 从开头匹配，返回match对象group或None
re.search 返回match对象group或None

re.split 用匹配文本分割，返回分割后的列表

re.subn 返回替换后的文本以及替换次数返回tuple

re.finditer 类似findall，返回迭代器对象，for遍历后match对象

compile(pattern, flags=0)
    Compile a regular expression pattern, returning a Pattern object.
    
    
template(pattern, flags=0)
    Compile a template pattern, returning a Pattern object

purge()
    Clear the regular expression caches
